"use strict";(self.webpackChunkdynamode_docs=self.webpackChunkdynamode_docs||[]).push([[272],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>y});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=p(n),y=r,b=u["".concat(l,".").concat(y)]||u[y]||m[y]||i;return n?a.createElement(b,o(o({ref:t},d),{},{components:n})):a.createElement(b,o({ref:t},d))}));function y(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},7267:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const i={title:"Modeling | Dynamode",description:"Modeling",sidebar_label:"Modeling",hide_title:!0},o="Modeling",s={unversionedId:"guide/entity/modeling",id:"guide/entity/modeling",title:"Modeling | Dynamode",description:"Modeling",source:"@site/docs/guide/entity/modeling.mdx",sourceDirName:"guide/entity",slug:"/guide/entity/modeling",permalink:"/dynamode/docs/guide/entity/modeling",draft:!1,editUrl:"https://www.github.com/blazejkustra/dynamode/tree/main/docs/docs/guide/entity/modeling.mdx",tags:[],version:"current",frontMatter:{title:"Modeling | Dynamode",description:"Modeling",sidebar_label:"Modeling",hide_title:!0},sidebar:"sidebar",previous:{title:"Configure",permalink:"/dynamode/docs/getting_started/configure"},next:{title:"Decorators",permalink:"/dynamode/docs/guide/entity/decorators"}},l={},p=[{value:"Possible values",id:"possible-values",level:2},{value:"Modeling with Typescript",id:"modeling-with-typescript",level:2},{value:"Decorators",id:"decorators",level:3},{value:"Additional methods",id:"additional-methods",level:3},{value:"Generic example",id:"generic-example",level:3},{value:"Examples",id:"examples",level:2},{value:"Key value",id:"key-value",level:3},{value:"User",id:"user",level:3},{value:"All possible properties",id:"all-possible-properties",level:3},{value:"Inheritance",id:"inheritance",level:3}],d={toc:p};function m(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"modeling"},"Modeling"),(0,r.kt)("p",null,"To better understand how to model with Dynamode it is recommended that you first read about DynamoDB. In comparison to relational databases, DynamoDB requires a different modeling approach. Here are some helpful documents:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.CoreComponents.html"},"Core components of Amazon DynamoDB")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.dynamodbguide.com/what-is-dynamo-db"},"DynamoDB Guide")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.dynamodbbook.com/"},"The DynamoDB Book - Alex DeBrie")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://dynobase.dev/dynamodb-tutorials/"},"DynamoDB Tutorials - Everything You Need To Master It"))),(0,r.kt)("h2",{id:"possible-values"},"Possible values"),(0,r.kt)("p",null,"DynamoDB limits possible data types that can be saved in the database. To learn more: ",(0,r.kt)("a",{parentName:"p",href:"https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.NamingRulesDataTypes.html"},"Supported data types and naming rules in Amazon DynamoDB"),"."),(0,r.kt)("p",null,"Supported DynamoDB data types and its Dynamode equivalents:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"DynamoDB type"),(0,r.kt)("th",{parentName:"tr",align:null},"Dynamode Typescript equivalent"),(0,r.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"No value"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"undefined")),(0,r.kt)("td",{parentName:"tr",align:null},"DynamoDB non existent values are mapped to ",(0,r.kt)("inlineCode",{parentName:"td"},"undefined"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Null")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"null")),(0,r.kt)("td",{parentName:"tr",align:null},"Null represents an attribute with an unknown or ",(0,r.kt)("inlineCode",{parentName:"td"},"undefined")," state.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"String")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"string")),(0,r.kt)("td",{parentName:"tr",align:null},"Partition and sort keys can't be empty strings.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Number")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"number")),(0,r.kt)("td",{parentName:"tr",align:null},"DynamoDB does not support ",(0,r.kt)("inlineCode",{parentName:"td"},"Infinite")," and ",(0,r.kt)("inlineCode",{parentName:"td"},"NaN")," values.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Binary")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Uint8Array")),(0,r.kt)("td",{parentName:"tr",align:null},"Binary data is represented using the ",(0,r.kt)("inlineCode",{parentName:"td"},"Uint8Array")," type. DynamoDB does not natively support other binary types such as ",(0,r.kt)("inlineCode",{parentName:"td"},"File"),"/",(0,r.kt)("inlineCode",{parentName:"td"},"Buffer"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Boolean")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"boolean")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true")," or ",(0,r.kt)("inlineCode",{parentName:"td"},"false"),".")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"List")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Array<unknown>")),(0,r.kt)("td",{parentName:"tr",align:null},"There are no restrictions on the data types that can be stored in an ",(0,r.kt)("inlineCode",{parentName:"td"},"Array"),". Elements in an array do not have to be of the same type.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Map")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Map<string, unknown>")," / ",(0,r.kt)("inlineCode",{parentName:"td"},"Record<string, unknown>")," / ",(0,r.kt)("inlineCode",{parentName:"td"},"{ [key: string]: unknown }")," / ",(0,r.kt)("inlineCode",{parentName:"td"},"{ [key]: unknown, ... }")),(0,r.kt)("td",{parentName:"tr",align:null},"There are no restrictions on the data types that can be stored in a ",(0,r.kt)("inlineCode",{parentName:"td"},"Map"),"/",(0,r.kt)("inlineCode",{parentName:"td"},"object"),". Elements in a map do not have to be of the same type.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Set")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Set<string>")," / ",(0,r.kt)("inlineCode",{parentName:"td"},"Set<number>")),(0,r.kt)("td",{parentName:"tr",align:null},"Set can only represent sets of ",(0,r.kt)("inlineCode",{parentName:"td"},"numbers")," or ",(0,r.kt)("inlineCode",{parentName:"td"},"strings"),". All the elements within a set must be of the same type.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"N/A"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Date")),(0,r.kt)("td",{parentName:"tr",align:null},"DynamoDB does not natively support a ",(0,r.kt)("inlineCode",{parentName:"td"},"Date")," data type. To store a ",(0,r.kt)("inlineCode",{parentName:"td"},"Date")," Dynamode uses Unix epoch (",(0,r.kt)("inlineCode",{parentName:"td"},"number"),") or Iso 8601 format (",(0,r.kt)("inlineCode",{parentName:"td"},"string"),").")))),(0,r.kt)("h2",{id:"modeling-with-typescript"},"Modeling with Typescript"),(0,r.kt)("p",null,"In order to start modeling you need to create a class that inherits ",(0,r.kt)("inlineCode",{parentName:"p"},"Entity"),"."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Make sure that your classes names are unique within a table. Dynamode uses class names to identify entities.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import Entity from 'dynamode/entity';\n\nclass YourModel extends Entity { \n  ...\n}\n")),(0,r.kt)("h3",{id:"decorators"},"Decorators"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Only decorated properties will be saved in the database.")," Thanks to this you can add undecorated properties to your entity that won't be saved but can be useful for your application logic."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"There are no limits to the number of attributes that you can add, but keep in mind the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ServiceQuotas.html"},"DynamoDB size limits"),".")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import attribute from 'dynamode/decorators';\n\nclass YourModel extends Entity {\n  // These attributes will be saved in the database (decorated)\n  @attribute.partitionKey.string()\n  key: ...;\n\n  @attribute.sortKey.string()\n  key: ...;\n\n  @attribute.gsi.partitionKey.string({ indexName: '...' })\n  key: ...;\n\n  @attribute.lsi.sortKey.number({ indexName: '...' })\n  key: ...;\n\n  @attribute.date.string()\n  key: ...;\n\n  @attribute.date.number()\n  key: ...;\n\n  @attribute.string()\n  key: ...;\n\n  // Won't be saved in the database (undecorated)\n  key: ...;\n\n  ...\n}\n")),(0,r.kt)("h3",{id:"additional-methods"},"Additional methods"),(0,r.kt)("p",null,"You can add non-static and static methods to your entities that you can call later. You can also add static properties that will be available in your class."),(0,r.kt)("admonition",{type:"danger"},(0,r.kt)("p",{parentName:"admonition"},"Do not override ",(0,r.kt)("inlineCode",{parentName:"p"},"Entity.dynamodeEntity")," static property, unless you know what you are doing.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"class YourModel extends Entity {\n  ...\n  \n  constructor(props: Props) {\n    super();\n    ... \n  }\n\n  public method() {\n    ...\n  }\n\n  public static staticMethod() {\n    ...\n  }\n}\n")),(0,r.kt)("h3",{id:"generic-example"},"Generic example"),(0,r.kt)("p",null,"Basic setup of a ",(0,r.kt)("inlineCode",{parentName:"p"},"YourModel")," class:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import Entity from 'dynamode/entity';\nimport { attribute } from 'dynamode/decorators';\n\n\n\ntype Props = {\n  key: string;\n  ...\n};\n\n\nclass YourModel extends Entity {\n  // Required\n  @attribute.partitionKey.string()\n  key: string;\n\n  // Optional\n  @attribute.prefix(...)\n  @attribute.suffix(...)\n  @attribute.sortKey.string()\n  @attribute.gsi.partitionKey.string(...)\n  @attribute.gsi.sortKey.number(...)\n  @attribute.lsi.sortKey.number(...)\n  @attribute.date.string()\n  @attribute.number()\n  @attribute.string()\n  @attribute.object()\n  @attribute.array()\n  @attribute.set()\n  @attribute.boolean()\n  name: any;\n\n  // Not saved in the database \n  otherName: any;\n\n  constructor(props: Props) {\n    super();\n\n    this.key = props.key;\n    // other initiations\n    ... \n  }\n\n  // Custom methods that can be called later\n  public method() {\n    ...\n  }\n\n  public static staticMethod() {\n    ...\n  }\n}\n")),(0,r.kt)("h2",{id:"examples"},"Examples"),(0,r.kt)("p",null,"Here are some example models that shows how flexible Dynamode modeling is. Note that the entities in every example operate on a different table, primary keys and indexes. So you can model your entities based on your needs."),(0,r.kt)("h3",{id:"key-value"},"Key value"),(0,r.kt)("p",null,"The simplest example with only key and value attributes. There is no sort key for the table, meaning it uses a ",(0,r.kt)("em",{parentName:"p"},"simple primary key"),". "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import Entity from 'dynamode/entity';\nimport { attribute } from 'dynamode/decorators';\nimport TableManager from 'dynamode/table';\n\ntype KeyValueProps = {\n  key: string;\n  value: Record<string, unknown>;\n};\n\nexport class KeyValue extends Entity {\n  @attribute.partitionKey.string()\n  key: string;\n\n  @attribute.object()\n  value: Record<string, unknown>;\n\n  constructor(props: KeyValueProps) {\n    super();\n\n    this.key = props.key;\n    this.value = props.value;\n  }\n}\n\nconst TABLE_NAME = 'key-value';\n\nexport const KeyValueTableManager = new TableManager(KeyValue, {\n  tableName: TABLE_NAME,\n  partitionKey: 'key',\n});\n\nexport const KeyValueManager = KeyValueTableManager.entityManager();\n")),(0,r.kt)("h3",{id:"user"},"User"),(0,r.kt)("p",null,"Another model without indexes but this time with a ",(0,r.kt)("em",{parentName:"p"},"composite primary key")," (with partition and sort keys)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import Entity from 'dynamode/entity';\nimport { attribute } from 'dynamode/decorators';\nimport TableManager from 'dynamode/table';\n\ntype UserProps = {\n  partitionKey: string;\n  sortKey: string;\n  username: string;\n  email: string;\n  age: number;\n  friends: string[];\n  config: {\n    isAdmin: boolean;\n  };\n};\n\nexport class User extends Entity {\n  @attribute.partitionKey.string()\n  partitionKey: string;\n\n  @attribute.sortKey.string()\n  sortKey: string;\n\n  @attribute.string()\n  username: string;\n\n  @attribute.string()\n  email: string;\n\n  @attribute.number()\n  age: number;\n\n  @attribute.array()\n  friends: string[];\n\n  @attribute.object()\n  config: {\n    isAdmin: boolean;\n  };\n\n  constructor(props: UserProps) {\n    super();\n\n    // Primary key\n    this.partitionKey = props.partitionKey;\n    this.sortKey = props.sortKey;\n\n    // Other properties\n    this.username = props.username;\n    this.email = props.email;\n    this.age = props.age;\n    this.friends = props.friends;\n    this.config = props.config;\n  }\n}\n\nconst USERS_TABLE = 'users';\n\nexport const UserTableManager = new TableManager(User, {\n  tableName: USERS_TABLE,\n  partitionKey: 'partitionKey',\n  sortKey: 'sortKey',\n});\n\nexport const UserManager = UserTableManager.entityManager();\n")),(0,r.kt)("h3",{id:"all-possible-properties"},"All possible properties"),(0,r.kt)("p",null,"A model with all possible properties that are supported in Dynamode. This model has a ",(0,r.kt)("em",{parentName:"p"},"composite primary key")," and two indexes."),(0,r.kt)("p",null,"This model also has two properties ",(0,r.kt)("inlineCode",{parentName:"p"},"createdAt")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"updatedAt")," that represent the timestamps of when the model was created or last updated."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"type AllPossiblePropertiesProps = {\n  partitionKey: string;\n  sortKey: string;\n  GSI_1_PK?: string;\n  GSI_1_SK?: number;\n  LSI_1_SK?: number;\n  createdAt?: Date;\n  updatedAt?: Date;\n\n  string: string;\n  object: {\n    optional?: string;\n    required: number;\n  };\n  array: string[];\n  map: Map<string, string>;\n  set: Set<string>;\n  number?: number;\n  boolean: boolean;\n};\n\nconst PREFIX = 'prefix';\n\nexport class AllPossibleProperties extends Entity {\n  // Primary key\n  @attribute.prefix(PREFIX)\n  @attribute.partitionKey.string()\n  partitionKey: string;\n\n  @attribute.sortKey.string()\n  sortKey: string;\n\n  // Indexes\n  @attribute.gsi.partitionKey.string({ indexName: 'GSI_1_NAME' })\n  GSI_1_PK?: string;\n\n  @attribute.gsi.sortKey.number({ indexName: 'GSI_1_NAME' })\n  GSI_1_SK?: number;\n\n  @attribute.lsi.sortKey.number({ indexName: 'LSI_1_NAME' })\n  LSI_1_SK?: number;\n\n  // Timestamps\n  @attribute.date.string()\n  createdAt: Date;\n\n  @attribute.date.number()\n  updatedAt: Date;\n\n  @attribute.string()\n  string: string;\n\n  @attribute.object()\n  object: {\n    optional?: string;\n    required: number;\n  };\n\n  @attribute.array()\n  array?: string[];\n\n  @attribute.map()\n  map: Map<string, string>;\n\n  @attribute.set()\n  set: Set<string>;\n\n  @attribute.number()\n  number?: number;\n\n  @attribute.boolean()\n  boolean: boolean;\n\n  unsaved: string;\n\n  constructor(props: AllPossiblePropertiesProps) {\n    super();\n\n    // Primary key\n    this.partitionKey = props.partitionKey;\n    this.sortKey = props.sortKey;\n\n    // Indexes\n    this.GSI_1_PK = props.GSI_1_PK;\n    this.GSI_1_SK = props.GSI_1_SK;\n    this.LSI_1_SK = props.LSI_1_SK;\n\n    // Timestamps\n    this.createdAt = props.createdAt || new Date();\n    this.updatedAt = props.updatedAt || new Date();\n\n    this.string = props.string;\n    this.object = props.object;\n    this.array = props.array;\n    this.map = props.map;\n    this.set = props.set;\n    this.number = props.number;\n    this.boolean = props.boolean;\n    this.unsaved = 'unsaved';\n  }\n\n  public method() {\n    console.log('method');\n  }\n\n  public static staticMethod() {\n    console.log('staticMethod');\n  }\n}\n\nconst TABLE_NAME = 'all-possible-properties';\n\nconst AllPossiblePropertiesTableManager = new TableManager(AllPossibleProperties, {\n  tableName: TABLE_NAME,\n  partitionKey: 'partitionKey',\n  sortKey: 'sortKey',\n  indexes: {\n    GSI_1_NAME: {\n      partitionKey: 'GSI_1_PK',\n      sortKey: 'GSI_1_SK',\n    },\n    LSI_1_NAME: {\n      sortKey: 'LSI_1_SK',\n    },\n  },\n  createdAt: 'createdAt',\n  updatedAt: 'updatedAt',\n});\n\nexport const AllPossiblePropertiesManager = AllPossiblePropertiesTableManager.entityManager();\n")),(0,r.kt)("h3",{id:"inheritance"},"Inheritance"),(0,r.kt)("p",null,"An important feature of Dynamode is the possibility to inherit entities multiple times. That means that models can share attributes, primary keys and indexes between each other (= less boilerplate)."),(0,r.kt)("p",null,"Notice that ",(0,r.kt)("inlineCode",{parentName:"p"},"Entity")," is only inherited once as all these models are bound to the same DynamoDB table. The idea is to have one base class that represent DynamoDB table (",(0,r.kt)("inlineCode",{parentName:"p"},"BaseTable"),"). The rest of the models (",(0,r.kt)("inlineCode",{parentName:"p"},"EntityOne"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"EntityTwo")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"EntityThree"),") are representing individual entities."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"type TableProps = {\n  propPk: string;\n  propSk: number;\n  index: string;\n};\n\nclass BaseTable extends Entity {\n  @attribute.partitionKey.string()\n  propPk: string;\n\n  @attribute.sortKey.number()\n  propSk: number;\n\n  @attribute.lsi.sortKey.string({ indexName: 'LSI_NAME' })\n  index: string;\n\n  constructor(props: TableProps) {\n    super();\n\n    this.propPk = props.propPk;\n    this.propSk = props.propSk;\n    this.index = props.index;\n  }\n}\n\ntype EntityOneProps = TableProps & {\n  one: { [k: string]: number };\n};\n\nexport class EntityOne extends BaseTable {\n  @attribute.object()\n  one: { [k: string]: number };\n\n  constructor(props: EntityOneProps) {\n    super(props);\n\n    this.one = props.one;\n  }\n}\n\ntype EntityTwoProps = EntityOneProps & {\n  two: { [k: string]: string };\n};\n\nexport class EntityTwo extends EntityOne {\n  @attribute.object()\n  two: { [k: string]: string };\n\n  constructor(props: EntityTwoProps) {\n    super(props);\n\n    this.two = props.two;\n  }\n}\n\ntype EntityThreeProps = TableProps & {\n  otherProperty: any;\n};\n\nexport class EntityThree extends BaseTable {\n  @attribute.object()\n  otherProperty: { [k: string]: number };\n\n  constructor(props: EntityThreeProps) {\n    super(props);\n\n    this.otherProperty = props.otherProperty;\n  }\n}\n\nconst TABLE_NAME = 'inheritance';\n\nexport const BaseTableManager = new TableManager(BaseTable, {\n  tableName: TABLE_NAME,\n  partitionKey: 'propPk',\n  sortKey: 'propSk',\n  indexes: {\n    LSI_NAME: {\n      sortKey: 'index',\n    },\n  },\n});\n\nexport const EntityOneManager = BaseTableManager.entityManager(EntityOne);\nexport const EntityTwoManager = BaseTableManager.entityManager(EntityTwo);\nexport const EntityThreeManager = BaseTableManager.entityManager(EntityThree);\n")))}m.isMDXComponent=!0}}]);